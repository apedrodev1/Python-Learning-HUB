"""
Database Repository Module for the Student Grade System.

This module defines the StudentRepository class, which abstracts all
database interactions (CRUD operations) using a data access layer pattern.
It is the only part of the application that should directly execute SQL.
"""

import sqlite3
from . import queries  
from src.classes.Student import Student 

class StudentRepository:
    
    """
    Manages all database operations for Student objects.

    This class handles the connection, cursor management, and translation
    between Student objects and the SQL database tables.

    Attributes:
        db_file (str): The file path to the SQLite database.
        conn (sqlite3.Connection): The active database connection.
    """

    def __init__(self, db_file):

        """
        Initializes the repository and connects to the database.

        Also ensures that foreign key support is enabled and that
        all necessary tables are created.

        Args:
            db_file (str): The path to the SQLite database file.

        Raises:
            sqlite3.Error: If the database connection fails.
        """

        self.db_file = db_file
        try:
            self.conn = sqlite3.connect(db_file)
            self.conn.execute("PRAGMA foreign_keys = ON;") # Enable foreign keys
            self._create_tables()
        except sqlite3.Error as e:
            print(f"Error connecting to database: {e}")
            raise
            

    def _create_tables(self):

        """
        Creates the database tables if they do not already exist.
        
        This is an internal method called during initialization.
        """

        try:
            cursor = self.conn.cursor()
            cursor.execute(queries.CREATE_STUDENTS_TABLE)
            cursor.execute(queries.CREATE_GRADES_TABLE)
            self.conn.commit()
        except sqlite3.Error as e:
            print(f"Error creating tables: {e}")


    def add_student(self, student):

        """
        Adds a new Student object to the database.

        This performs two operations in a single transaction:
        1. Inserts the main student data into the 'students' table.
        2. Inserts all associated marks/weights into the 'grades' table.

        Args:
            student (Student): The Student object to add.

        Returns:
            int or None: The new student's ID from the database if successful,
                         otherwise None.
        """

        try:
            cursor = self.conn.cursor()
            
            # 1. Insert the student into the 'students' table
            cursor.execute(queries.INSERT_STUDENT, (
                student.name,
                student.passing_grade,
                1 if student.is_weighted else 0
            ))
            
            # Get the ID just generated by the database
            student_db_id = cursor.lastrowid
            
            # 2. Insert the grades and weights into the 'grades' table
            
            # Use 1.0 as default weight for arithmetic average
            weights = student.weights_marks if student.is_weighted else [1.0] * len(student.marks)
            
            for mark, weight in zip(student.marks, weights):
                cursor.execute(queries.INSERT_GRADE, (
                    student_db_id,
                    mark,
                    weight
                ))
                
            self.conn.commit()
            print(f"Student {student.name} added to database with ID {student_db_id}.")
            return student_db_id
            
        except sqlite3.Error as e:
            self.conn.rollback() # Roll back any changes if an error occurs
            print(f"Error adding student {student.name}: {e}")
            return None


    def get_all_students(self):

        """
        Fetches all students from the database and reconstructs them.

        This method reads from both 'students' and 'grades' tables
        to build a complete list of Student objects.

        Returns:
            list[Student]: A list of all Student objects in the database.
                           Returns an empty list if an error occurs.
        """

        try:
            cursor = self.conn.cursor()
            cursor.execute(queries.SELECT_ALL_STUDENTS)
            student_rows = cursor.fetchall()
            
            student_list = []
            for row in student_rows:
                student_db_id, name, passing_grade, is_weighted_int = row
                is_weighted = bool(is_weighted_int) # Convert 0/1 to False/True
                
                # Fetch the corresponding grades for this student
                cursor.execute(queries.SELECT_GRADES_FOR_STUDENT, (student_db_id,))
                grade_rows = cursor.fetchall() # e.g., [(8.0, 1.0), (7.5, 1.0)]
                
                # Unpack the list of tuples
                marks = [g[0] for g in grade_rows]
                weights = [g[1] for g in grade_rows]
                
                # Re-create the Student object
                student = Student(
                    student_id=student_db_id, # Use the ID from the DB
                    name=name,
                    passing_grade=passing_grade,
                    weights_marks=weights if is_weighted else [],
                    is_weighted=is_weighted
                )
                student.marks = marks # Use the setter to load marks
                
                student_list.append(student)
            
            return student_list
        
        except sqlite3.Error as e:
            print(f"Error fetching students: {e}")
            return [] # Return an empty list on failure


    def update_student(self, student):

        """
        Updates an existing student in the database.

        This follows a "delete and recreate" strategy for grades to ensure
        consistency, as it's simpler than tracking individual grade changes.

        Args:
            student (Student): The Student object containing the updated data.
                               The 'student.student_id' must be valid.
        """

        try:
            cursor = self.conn.cursor()
            
            # 1. Update the main data in the 'students' table
            cursor.execute(queries.UPDATE_STUDENT_DATA, (
                student.name,
                student.passing_grade,
                1 if student.is_weighted else 0,
                student.student_id # Use the ID for the 'WHERE' clause
            ))
            
            # 2. Delete ALL old grades for this student
            cursor.execute(queries.DELETE_GRADES_FOR_STUDENT, (student.student_id,))
            
            # 3. Re-insert the (now updated) grades
            weights = student.weights_marks if student.is_weighted else [1.0] * len(student.marks)
            
            for mark, weight in zip(student.marks, weights):
                cursor.execute(queries.INSERT_GRADE, (
                    student.student_id,
                    mark,
                    weight
                ))
                
            self.conn.commit()
            print(f"Student {student.name} (ID: {student.student_id}) updated in database.")
            
        except sqlite3.Error as e:
            self.conn.rollback()
            print(f"Error updating student {student.name}: {e}")


    def delete_student(self, student_id):

        """
        Deletes a student from the database using their ID.

        Thanks to 'ON DELETE CASCADE', all associated entries in the
        'grades' table will be deleted automatically.

        Args:
            student_id (int): The ID of the student to delete.
        """

        try:
            cursor = self.conn.cursor()
            cursor.execute(queries.DELETE_STUDENT_BY_ID, (student_id,))
            self.conn.commit()
            print(f"Student (ID: {student_id}) deleted from database.")
            
        except sqlite3.Error as e:
            self.conn.rollback()
            print(f"Error deleting student (ID: {student_id}): {e}")


    def close(self):

        """Closes the connection to the database."""
        
        if self.conn:
            self.conn.close()